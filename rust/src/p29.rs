// Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
// 22=4, 23=8, 24=16, 25=32
// 32=9, 33=27, 34=81, 35=243
// 42=16, 43=64, 44=256, 45=1024
// 52=25, 53=125, 54=625, 55=3125

// 62=36, 63=216, 64=1296, 65=7776
// 82=64 83=512
// If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
// 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125 ===> 15
// 4, 8, 9, 16, 25, 27, 32, 36, 64, 81, 125, 216, 243, 256, 625, 1024, 1296, 3125, 7776 ===> 19
// How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
use std::num::*;

fn main () {
    println!("Result -> {}",
             count_divisible_by_up_to(1, 1*5)
             + count_divisible_by_up_to(2, 2*5) - count_divisible_by_up_to(1*2, 1*5)
             + count_divisible_by_up_to(3, 3*5) - count_divisible_by_up_to(2*3, 2*5)
             + count_divisible_by_up_to(4, 4*5) - count_divisible_by_up_to(3*4, 3*5)
             + count_divisible_by_up_to(5, 5*5) - count_divisible_by_up_to(4*5, 4*5)
             + count_divisible_by_up_to(6, 6*5) - count_divisible_by_up_to(5*6, 5*5)
             );
}

fn calculate_uniques(a: i32, b: i32) -> i32{
    use std::collections::HashMap;

    let (mut i, mut result) = (2, 0);
    let mut calculated_digits = HashMap::new();

    while i <= a{
        if !calculated_digits.contains_key(&i) {
            let mut l = 2;
            result += b - 1;
            while i.pow(l) <= a {


                calculated_digits.insert(i.pow(l), true);
                result += b - (b as f32 / l as f32).floor() as i32;
                l += 1;
            }
        } else {
            // println!("{} has already been calculated!", i);
        }
        i += 1;

    }
    return result;
}

fn count_divisible_by_up_to(n: i32, l: i32) -> i32 {
    let (mut count, mut r) = (0i32, n);

    while r <= l {
        count += 1;
        r += n;
    }

    return count - 1;
}
